import xy.ctti in ctti
import libxy.units
import libxy.memory
import libxy.stdio
import libxy.strings
import libxy.slices

struct Array~[elemType: struct] {
    mem: Memory;
    len: Size~Count;
}

def len(a: Array) = a.len

def max(a: Size, b: Size) -> Size {
    return if (a > b) a else b;
}

def ensureCapacity(
    arr: inout Array,
    requiredCap: Size,
    elemSize : Size = arr'typeof'tagsof.elemType'sizeof
) {
    minRequiredSize := requiredCap * elemSize;
    if (arr.mem.size < minRequiredSize) {
        arr.mem'realloc(max(minRequiredSize, 2 * arr.mem.size));
    }
}

def push(
    arr: inout Array,
    elem: pseudo ?,
    elemMem: Ptr = elem'addrof,
    elemSize := elem'sizeof
)
# >> ctti.compatible(arr'typeof'tagsof.elemType, elem'typeof, arr, elem)
{
    arr'ensureCapacity(arr.len + 1, elemSize=elemSize);
    arr.mem[arr.len * elemSize +: elemSize] = elemMem;
    arr.len++;
}


def get(
    arr: Array, i: Size,
    elemSize : Size = arr'typeof'tagsof.elemType'sizeof
) -> ref(arr) Ptr~[<< arr'typeof'tagsof.elemType] {
    return arr.mem.addr + i * elemSize;
}

def get(
    arr: Array, i: int,
    elemSize : Size = arr'typeof'tagsof.elemType'sizeof
) -> ref(arr) Ptr~[<< arr'typeof'tagsof.elemType] {
    return arr.mem.addr + i * elemSize;
}

# def get(arr: Array, i:Size, elemSize := arr'tagsof.elemType'sizeof) -> Ptr~[arr'tagsof.elemType] {
#     return arr.mem.addr + (i * elemSize);
# }

struct ArrayIter {
    idx: Size;
}

def iter(arr: Array) ArrayIter{}

def valid(iter: ArrayIter, arr: Array) = iter.idx < arr'len

def next(iter: ArrayIter, arr: pseudo Array) = ArrayIter{iter.idx+1}

def deref(iter: ArrayIter, arr: Array, elemSize : Size = arr'typeof'tagsof.elemType'sizeof) -> ref(arr) Ptr~[<< arr'typeof'tagsof.elemType] {
#    return arr.mem'at(i * elemSize)'as(outin);
}

# ----------------- test code -----------------

struct Point {
    x: int;
    y: int;
}

def main~EntryPoint() -> int {
    ints: Array~int;
    points: Array~Point;
    for (i in :100) {
        ints'push(i);
        points'push(Point{ints[ints'len -1 -i] + i, ints[i]});
    }

    print(f"len={ints'len}\n");

    res : int;
    for (i in :100) {
        res *= (points[i].x - points[i].y) * ints[i] - i;
        res *= (points[i].x - points[i].y);
    }

    #res := for (i in :, num in ints, point in points) -> (res := 0) {
    #    res *= (point.x - point.y) * num - i;
    #};
    #print(f"{=res}\n");

    return 0;
}
