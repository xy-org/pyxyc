import xy.ctti in ctti;
import libxy.unit;
import libxy.memory;
import libxy.stdio;
import libxy.string;
import libxy.slice;
import libxy.error;

struct Array~[elemType: struct, xy_dtor=true] {
    mem: Memory;
    len: Usize~Count;
}

func dtor(arr: mut Array) {
    arr.mem'free();
}

func len(a: Array) = a.len;

func max(a: Usize, b: Usize) -> Usize {
    return if (a > b) a else b;
}

func ensureCapacity(
    arr: mut Array,
    requiredCap: Usize,
    elemSize : Usize = ctti.sizeof(arr..elemType)
) {
    minRequiredSize := requiredCap * elemSize;
    if (arr.mem.size < minRequiredSize) {
        arr.mem'realloc(max(minRequiredSize, 2 * arr.mem.size));
    }
}

func push(
    arr: mut Array,
    elem: pseudo Any,
    elemMem: Ptr = elem'addrof,
    elemSize := ctti.sizeof(elem)
)
# >> ctti.compatible(arr..elemType, %elem, arr, elem)
{
    arr'ensureCapacity(arr.len + 1, elemSize=elemSize);
    arr.mem[arr.len * elemSize +: elemSize] = elemMem;
    arr.len++;
}


func get(
    arr: Array, i: Usize,
    elemSize : Usize = ctti.sizeof(arr..elemType)
) -> arr[ Ptr~[^arr..elemType] ] {
    return (arr.mem.addr + i * elemSize)~[void];
}

func get(
    arr: Array, i: Int,
    elemSize : Usize = ctti.sizeof(arr..elemType)
) -> arr[ Ptr~[^arr..elemType] ] {
    return (arr.mem.addr + i'to(Usize) * elemSize)~void;
}

struct ArrayIter {
    idx: Usize;
}

func iter(arr: Array) -> arr[ ArrayIter ] {
    return ArrayIter{};
}

func valid(arr: Array, iter: ArrayIter) = iter.idx < arr'len;

func next(arr: pseudo Array, iter: mut ArrayIter) {
   iter.idx++;
}

func get(arr: Array, iter: ArrayIter, elemSize : Usize = ctti.sizeof(arr..elemType)) -> arr[ Ptr~[^arr..elemType] ] {
    return (arr.mem.addr + iter.idx * elemSize)~void;
}

# ----------------- test code -----------------

struct Point {
    x: Int;
    y: Int;
}

func main~EntryPoint() {
    ints: Array~Int;
    points: Array~Point;
    for (i in :100) {
        ints'push(i);
        points'push(Point{ints[ints'len -1 -i'to(Usize)] + i, ints[i]});
    }

    print(f"len={ints'len}\n");

    res : Int;
    for (i in :100) {
        res += (points[i].x - points[i].y) * ints[i] - i;
        res += (points[i].x - points[i].y);
    }

    for (i in :, num in ints, point in points) {
        res += (point.x - point.y) * num - i'to(Int);
    };

    print(f"{=res}\n");
}
