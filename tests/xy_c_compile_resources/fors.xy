def busywait() {
    for (i in :) {
        if (i == 10000) break;
    }
}

def sumUpTo(start: int, end: int) -> int {
    return for (i in start:end) -> (res: int) res += i;
}

def multUpTo(start: int, end: int, step: int) -> int {
    res : var = 0;
    for (i in start:end:step) res *= sumUpTo(start, i);
    return res;
}

def doubleLoop(limX: int, limY: int) -> int {
    return for (i in :limX) -> (res := 1) for (j in :limY) {
        res *= i + j;
    };
}

def zipLoop(limX: int, limY: int) -> int {
    return for (i in :limX, j in :limY) -> (res := 1) res *= i + j;
}

# ;; Fibonacci number iteerator
# ;; --------------------------
# 
# struct Fib {
#     a := 1;
#     b := 0;
# }
# 
# def fibonacci~IterCtor() = Fib{}
# 
# def valid(fib: Fib) = true
# 
# def next(fib: Fib) = Fib{fib.a + fib.b, fib.a}
# 
# def deref(fib: Fib) = fib.a
# 
# ;; Multiplies the first {lim} fibonacci numbers
# def mulFibs(lim: int) -> int {
#     return for (_ in :lim, fib in fibonacci()) -> (res := 1) res *= fib;
# }
