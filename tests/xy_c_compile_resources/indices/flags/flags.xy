import posix~[Clib{headers=@{"unistd.h", "fcntl.h"}}] in c;

# Flags structure

struct Flag {
    value: Int,
}

struct OpenFlags {
    value : Int,

    readOnly : pseudo = Flag{c.O_RDONLY},
    writeOnly : pseudo = Flag{c.O_WRONLY},
    readWrite : pseudo = Flag{c.O_RDWR},
    append : pseudo = Flag{c.O_APPEND},
}

func get(base: OpenFlags, flag: Flag) -> Bool {
    return (base.value'to(Bits32) && flag.value'to(Bits32))'to(Int) == flag.value;
}

func set(base: mut OpenFlags, flag: Flag, set: Bool) {
    base.value = (base.value'to(Bits32) || (flag.value * set)'to(Bits32))'to(Int);
}

func cmpEq(l: OpenFlags, r: OpenFlags) l.value == r.value;

func or(l: OpenFlags, r: OpenFlags) OpenFlags{(l.value'to(Bits32) || r.value'to(Bits32))'to(Int)};

func and(l: OpenFlags, r: OpenFlags) OpenFlags{(l.value'to(Bits32) && r.value'to(Bits32))'to(Int)};

# Testing structures and functions

struct String {
    addr: Ptr,
    size: Usize,
}

func string~[StrCtor{prefix=""}](addr: Ptr, size: Usize) -> String {
    return String{addr, size};
}

func open(fn: String, flags := OpenFlags{+readOnly}) {
    if (flags.readWrite) {
        # reading, writing and maybe something else
    } elif (flags == OpenFlags{+readOnly, +append}) {
        # reading and appending only ...
    } elif (flags.readOnly) {
        # at least reading ...
    } elif (flags.writeOnly) {
        # at least writing ...
    }
}

func test1() {
    open("file.txt");
    open("file.txt", OpenFlags{+readOnly});
}

func test2() {
    open("file.txt", OpenFlags{+readOnly} || OpenFlags{+writeOnly});
    open("file.txt", OpenFlags{+writeOnly, +append});
}

func test3() {
    flags: OpenFlags;
    flags.writeOnly = true;
    open("file.txt", flags);
    open("file.txt", flags{+append});
    open("file.txt", flags{});
    open("file.txt", flags || OpenFlags{+readOnly});
}

func test4(flags: OpenFlags) {
    flags2 := OpenFlags{+append};
    open("file.txt", flags || flags2);
    open("file.txt", flags && flags2);
}
