import posix~[Clib{headers=@{"unistd.h", "fcntl.h"}}] in c;

# Flags structure

struct OpenFlags {
    value : Int;

    readOnly : pseudo = OpenFlags{c.O_RDONLY};
    writeOnly : pseudo = OpenFlags{c.O_WRONLY};
    readWrite : pseudo = OpenFlags{c.O_RDWR};
    append : pseudo = OpenFlags{c.O_APPEND};
}

func get(base: OpenFlags, fields: OpenFlags) -> Bool {
    return (base.value'to(Bits32) && fields.value'to(Bits32))'to(Int) == fields.value;
}

func set(base: mut OpenFlags, fields: OpenFlags, set: Bool) {
    base.value = (base.value'to(Bits32) || (fields.value * set'to(Int))'to(Bits32))'to(Int);
}

func cmpEq(l: OpenFlags, r: OpenFlags) l.value == r.value;

func or(l: OpenFlags, r: OpenFlags) OpenFlags{(l.value'to(Bits32) || r.value'to(Bits32))'to(Int)};

func and(l: OpenFlags, r: OpenFlags) OpenFlags{(l.value'to(Bits32) && r.value'to(Bits32))'to(Int)};

# Testing structures and functions

struct String {
    addr: Ptr;
    size: Usize;
}

func string~[StrCtor{prefix=""}](addr: Ptr, size: Usize) -> String {
    return String{addr, size};
}

func open(fn: String, flags:=OpenFlags.readOnly) {
    if (flags.readWrite) {
        # reading, writing and maybe something else
    } elif (flags == OpenFlags{.readOnly, .append}) {
        # reading and appending only ...
    } elif (flags.readOnly) {
        # at least reading ...
    } elif (flags.writeOnly) {
        # at least writing ...
    }
}

func test1() {
    open("file.txt");
    open("file.txt", OpenFlags.readOnly);
}

func test2() {
    open("file.txt", OpenFlags.readOnly || OpenFlags.writeOnly);
    open("file.txt", OpenFlags{.writeOnly, .append});
}

func test3() {
    flags: OpenFlags;
    flags.writeOnly = true;
    open("file.txt", flags);
    open("file.txt", flags{.append});
    open("file.txt", flags{});
    open("file.txt", flags || OpenFlags{.readOnly});
}

func test4(flags: OpenFlags) {
    flags2 := OpenFlags{.append};
    open("file.txt", flags || flags2);
    open("file.txt", flags && flags2);
}
