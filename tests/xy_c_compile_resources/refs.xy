struct Point {
    x: float;
    y: float;
    z: float;
    w: float = 1.0f;
}

def select(p: Point, idx: int) -> ref(p) int {
    return idx;
}

def get(p: Point, idx: int) -> float {
    return [p.x, p.y, p.z, p.w][idx];
}

def set(p: inout Point, idx: int, v: float)
>> idx <= 3
{
    if (idx == 0) {
        p.x = v;
    } elif (idx == 1) {
        p.y = v;
    } elif (idx == 2) {
        p.z = v;
    } else {
        p.w = v;
    }
}

def testPoint(i: int) -> float {
    p1: var = Point{w=i'to(float)};
    p2: Point;
    p1.x = p1[i];
    p2.z = p1[4-i];
    sum := p1.x + p2[2] + p2.z + p1[3];
    res : var = p1[0];
    p2[0] = p1[0];
    res += p2[0];
    return res + sum;
}

# struct  PointCloud {
#     mem: Ptr;
#     len: Size;
# }
# 
# def select(pc: PointCloud, i: Size) -> ref(pc) Size = i
# 
# def get(pc: inout PointCloud, i: Size) -> ref(pc) Ptr~Point = pc.mem.addr + i * sizeof(Point)
# 
# def set(pc: inout PointCloud, i: Size, p: Point) {
#     # not implemented for brievity
# }
# 
# def testPointCloud(m0: inout PointCloud, m1: PointCloud) {
#     m0[0].y = 10;
# 
#     print(m1[1].y);
#     print(m1[1]);
# 
#     m2 : var = Mesh{};
#     m2[2] = m0[2];
#     m2[2].x = m0[2].y;
#     m2[4] .= {x=5, y=10};
# 
#     m3 := PointCloud{};
#     print(m3[3].z);
#     print(m3[3]);
#     print(m3[3][3]);
# }
