# Header files "stdint.h", "stddef.h", "stdbool.h" are auto imported in symbol c

;; NOTE void is not a type in xy (unlike c).
;; 'void' has the meaning of removing, voiding, or not having something.

;; Special type that matches any other type in function selection
;; This is a compile-time only type. Cannot be instantiated.
;; Any parameter with that type is automatically marked pseudo.
*struct Any {
    # Compile-time only
}

;; Special type that describes a field in a struct.
;; This struct is empty as all the information it carries is compile time.
*struct Field~[
    type: Any,
] {
    # Empty
}

;; Get the field {field} from {data}
;; NYI
*func get(data: Any, field: Field) -> data[ Ptr~[^field..type] ] {
    # implemented by the compiler
}

;; Set field {field} of {data} to {val}
;; NYI
*func set(data: Any, field: Field, val: Any) {
    # implemented by the compiler
}

# Primitive bool type

;; 1-bit true/false type
;; The sizeof(Bool) is 0 as sizeof doesn't support sub-byte sizes
;; Pointers to Bool are not possible as pointers point to bytes
*struct Bool {
    # Implemented by the compiler
}

# Primitive numeric types.

;; 8-bit signed integer type
*struct Byte {
    # Implemented by the compiler
}

;; 16-bit signed integer type
*struct Short {
    # Implemented by the compiler
}

;; 32-bit signed integer type
*struct Int {
    # Implemented by the compiler
}

;; 32-bit signed unicode character/codepoint
;; No input validation is performed so even values outside of the Unicode
;; codepoint range (0 - 1_114_111) can be used as long as they fit in 32 bits.
*struct Char {
    # Implemented by the compiler
}

;; 64-bit signed integer type
*struct Long {
    # Implemented by the compiler
}

;; 8-bit unsigned integer type
*struct Ubyte {
    # Implemented by the compiler
}

;; 16-bit unsigned integer type
*struct Ushort {
    # Implemented by the compiler
}

;; 32-bit unsigned integer type
*struct Uint {
    # Implemented by the compiler
}

;; 64-bit unsigned integer type
*struct Ulong {
    # Implemented by the compiler
}

;; Synonym for a *signed* integer type as large as the addressable memory on
;; the target machine. This synonym is (by definition) platform dependant. It
;; is provided for interfacing with native libraries.
*Size := Long;

;; Same as {Size} but unsigned.
*Usize := Ulong;

;; A good old pointer. Use with caution.
*struct Ptr~[to: struct] {
    # Implemented by the compiler
}

;; Dereferencing a pointer
*func get(ptr: Ptr) -> [ Ptr~[^ptr..to] ] {
    # Implemented by the compiler
}

;; Dereferencing a pointer at an index (offset)
*func get(
    ptr: Ptr,
    idx: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong)
) -> [ Ptr~[^ptr..to] ] {
    # Implemented by the compiler
}

*func set(
    ptr: Ptr,
    idx: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong),
    value: pseudo Any
) -> void {
    # Implemented by the compiler
}

;; The address of Any variable or even temporary value
*func addrof(arg: Any) -> Ptr~[%^arg] {
    # Implemented by the compiler
}

;; 32-bit IEEE 754 floating point number
*struct Float {
    # Implemented by the compiler
}

;; 64-bit IEEE 754 floating point number
*struct Double {
    # Implemented by the compiler
}

*func inf(: Float) -> Float {
    # implemented by the compiler
}

*func inf(: Double) -> Double {
    # implemented by the compiler
}

*func nan(: Float) -> Float {
    # implemented by the compiler
}

*func nan(: Double) -> Double {
    # implemented by the compiler
}

# Limits

*func max(
    type: pseudo (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong)
 ) -> %type {
    # Implemented by the compiler
}

*func min(
    type: pseudo (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong)
 ) -> %type {
    # Implemented by the compiler
}

# Arithmetic operations

;; Addition
*func add(
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Float, Double),
    b: %a
) -> %a {
    # Implemented by the compiler
}

;; Equivalent to if({b}) {a}+1 else {a};
*func add(
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Float, Double),
    b: Bool
) -> %a {
    # Implemented by the compiler
}

*func add(
    b: Bool,
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Float, Double),
) -> %a {
    # Implemented by the compiler
}

*func add(
    char: Char,
    offset: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong),
) -> %char {
    # Implemented by the compiler
}

*func sub(
    char: Char,
    offset: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong),
) -> %char {
    # Implemented by the compiler
}

;; Subtraction
;; Note! Only Numeric - Bool is defined
*func sub(
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Float, Double),
    b: %a
) -> %a {
    # Implemented by the compiler
}

;; Equivalent to if({b}) {a}-1 else {a};
*func sub(
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Float, Double),
    b: Bool
) -> %a {
    # Implemented by the compiler
}

;; Multiplication
*func mul(
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Float, Double),
    b: %a
) -> %a {
    # Implemented by the compiler
}

;; Multiplie two 64-bit values, and return bits[64:127] of the 128-bit result
*func mulhi(a: (Long, Ulong), b: %a) -> %a {
    # implemented by the compiler
}

;; Power a.k.a. exponentiation
*func pow(
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Float, Double),
    b: %a
) -> %a {
    # Implemented by the compiler
}

;; Integer Division
;; Rounding is always towards zero.
;; Examples:
;; 7 / 4 == 1
;; 7 / -4 == -1
*func div(
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong),
    b: %a
) -> %a
>> b != %b
{
    # Implemented by the compiler
}

;; Floating Point Division
*func div(
    a: (Float, Double), b: %a
) -> %a {
    # Implemented by the compiler
}

*func div(
    b: Bool,
    a: (Float, Double),
) -> %a {
    # Implemented by the compiler
}

;; Remainder after integer division
;; It is defined as rem(a, b) = a - (a \div b) * b.
;; The sign of the result is the same as the sign of the dividend {a}.
;; Examples:
;; 7 \rem 4 == 1
;; 7 \rem -4 == 3
;; -7 \rem 4 == -3
;; -7 \rem -4 == -3
;; The divisor is assumed to be non-zero.
*func rem(
    dividend: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong),
    divisor: %dividend
) -> %dividend
>> divisor != %divisor
{
    # implemented by the compiler
}

## Comparison operators

;; Compare {a} and {b}
*func cmpEq(a: Any, b: Any) ^cmp(a, b) == 0;

;; Compare {a} and {b} for inequality
*func cmpNe(a: Any, b: Any) ^cmp(a, b) != 0;

;; True if {a} > {b}
*func cmpGt(a: Any, b: Any) ^cmp(a, b) > 0;

;; True if {a} >= {b}
*func cmpGe(a: Any, b: Any) ^cmp(a, b) >= 0;

;; True if {a} < {b}
*func cmpLt(a: Any, b: Any) ^cmp(b, a) > 0;

;; True if {a} < {b}
*func cmpLe(a: Any, b: Any) ^cmp(b, a) >= 0;

;; Return 1 if {a} > {b}, 0 if {a} == {b}, -1 if {a} < {b} or there is no order
*func cmp(
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Float, Double, Char),
    b: %a
) -> Int {
    # implemented by the compiler
}

## Ptr

*func add(
    ptr: Ptr,
    offset: (Byte, Ubyte, Short, Ushort, Int, Uint, Ulong, Long)
) -> Ptr~[^ptr..to] {
    # implemented by the compiler
}

*func sub(
    ptr: Ptr,
    offset: (Byte, Ubyte, Short, Ushort, Int, Uint, Ulong, Long)
) -> Ptr~[^ptr..to] {
    # implemented by the compiler
}

;; Compare pointers
*func cmp(a: Ptr, b: Ptr) -> Int {
    # Implemented by the compiler
}

## Logic Operations

;; Logic not
*func not(
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Bool)
) -> Bool {
    # Implemented by the compiler
}

;; True if {a} is NULL, false otherwise
*func not(a: Ptr) -> Bool {
    # Implemented by the compiler
}

;; Operator ++
*func inc(
    a: mut (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong)
) -> void {
    # Implemented by the compiler
}

;; Operator --
*func dec(
    a: mut (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong)
) -> void {
    # Implemented by the compiler
}

;; Min of two numbers
*func min(
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Float, Double),
    b: %a
) -> %a {
    # implemented by the compiler
}

;; Max of two numbers
*func max(
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Float, Double),
    b: %a
) -> %a {
    # implemented by the compiler
}

# Mixed signedness arithmetics

;; Compute operation only if {b} is a constant
*func add(
    a: (Byte, Ubyte, Short, Ushort, Uint, Long, Ulong, Float, Double),
    b: Int
) -> %a
>> isConst(^b)
{
    # implemented by the compiler
}

;; ...
*func sub(
    a: (Byte, Ubyte, Short, Ushort, Uint, Long, Ulong, Float, Double),
    b: Int
) -> %a
>> isConst(^b)
{
    # implemented by the compiler
}

;; ...
*func mul(
    a: (Byte, Ubyte, Short, Ushort, Uint, Long, Ulong, Float, Double),
    b: Int
) -> %a
>> isConst(^b)
{
    # implemented by the compiler
}

;; Equivalent to if ({b}) {a} else %{a}{}
*func mul(
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Float, Double),
    b: Bool
) -> %a
{
    # implemented by the compiler
}

*func mul(
    b: Bool,
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Float, Double),
) -> %a
{
    # implemented by the compiler
}

;; ...
*func div(
    a: (Byte, Ubyte, Short, Ushort, Uint, Long, Ulong, Float, Double),
    b: Int
) -> %a
>> isConst(^b)
{
    # implemented by the compiler
}

;; ...
*func cmp(a: (Ubyte, Ushort, Uint, Ulong), b: Int) -> Int
>> isConst(^b)
{
    # implemented by the compiler
}

;; Compute mixed signedness operation only if {a} is a constant
*func add(a: Int, b: (Uint, Ulong, Float, Double)) -> %b
>> isConst(^a)
{
    # implemented by the compiler
}

;; ...
*func sub(a: Int, b: (Uint, Ulong, Float)) -> %b
>> isConst(^a)
{
    # implemented by the compiler
}

;; ...
*func mul(
    a: Int,
    b: (Byte, Ubyte, Short, Ushort, Uint, Long, Ulong, Float, Double)
) -> %b
>> isConst(^a)
{
    # implemented by the compiler
}

;; ...
*func div(a: Int, b: (Uint, Ulong, Float)) -> %b
>> isConst(^a)
{
    # implemented by the compiler
}

;; ...
*func cmp(a: Int, b: (Ubyte, Ushort, Uint, Ulong)) -> Int
>> isConst(^a)
{
    # implemented by the compiler
}

# Conversion between types

;; Convert {a} to Ubyte
*func to(
    a: (Bool, Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong,
        Float, Double, Char),
    :Ubyte
) -> Ubyte {
    # Implemented by the compiler
}

;; Convert {a} to Byte
*func to(
    a: (Bool, Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong,
        Float, Double, Char),
    :Byte
) -> Byte {
    # Implemented by the compiler
}

;; Convert {a} to Short
*func to(
    a: (Bool, Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong,
        Float, Double, Char),
    :Short
) -> Short {
    # Implemented by the compiler
}

;; Convert {a} to Ushort
*func to(
    a: (Bool, Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong,
        Float, Double, Char),
    :Ushort
) -> Ushort {
    # Implemented by the compiler
}

;; Convert {a} to Int
*func to(
    a: (Bool, Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong,
        Float, Double, Char),
    :Int
) -> Int {
    # Implemented by the compiler
}


;; Convert {a} to Uint
*func to(
    a: (Bool, Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong,
        Float, Double, Char),
    :Uint
) -> Uint {
    # Implemented by the compiler
}

;; Convert {a} to Long
*func to(
    a: (Bool, Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong,
        Float, Double, Char),
    :Long
) -> Long {
    # Implemented by the compiler
}


;; Convert {a} to Ulong
*func to(
    a: (Bool, Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong,
        Float, Double, Char),
    :Ulong
) -> Ulong {
    # Implemented by the compiler
}

;; Convert {a} to Float
*func to(
    a: (Bool, Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong,
        Float, Double, Char),
    :Float
) -> Float {
    # Implemented by the compiler
}

;; Convert {a} to Double
*func to(
    a: (Bool, Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong,
        Float, Double, Char),
    :Double
) -> Double {
    # Implemented by the compiler
}

;; Convert {a} to Bool
*func to(
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong,
        Float, Double, Char),
    :Bool
) -> Bool {
    # Implemented by the compiler
}

;; Convert {a} to Char
*func to(
    a: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong),
    :Char
) -> Char {
    # Implemented by the compiler
}

# Logical operations

*func and(a: Bool, ^b: Bool) -> Bool {
    # Implemented by the compiler
}

*func or(a: Bool, ^b: Bool) -> Bool {
    # Implemented by the compiler
}

*func xor(a: Bool, b: Bool) -> Bool {
    # Implemented by the compiler
}

# Tag related stuff

;; Use this struct to tag other structs that are intended to be used as tags
;; themselves
struct TagCtor {
    # Implemented by the compiler
}

# String related stuff

;; Use this struct to mark functions that construct strings
struct StrCtor {
    # Implemented by the compiler
}

;; Use this struct to mark functions that unstring strings
struct UnstrCtor {
    # Implemented by the compiler
}

# Arrays

;; Get the element at position {index} from the array {arr}
*func get(
    arr: pseudo @Any[],
    index: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong)
) -> arr[ Ptr ] {
    # Implemented by the compiler
}

;; Set element at position {index} of the array {arr}
*func set(
    arr: pseudo @Any[],
    index: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong),
    val: pseudo Any
) -> void {
    # Implemented by the compiler
}

;; Use this struct to mark the function that should be used as the program
;; entry point. If multiple entry points are found during compilation
;; the one with the highest priority is used. If there are more than one
;; function with the highest priority then a compilation error is reported.
struct EntryPoint {
    priority: Int;
}

# Arrays

*func iter(arr: pseudo @Any[]) -> arr[ Usize ] {
    # Implemented by the compiler
}

*func valid(arr: pseudo @Any[], idx: Usize) -> Bool {
    # Implemented by the compiler
}

*func next(arr: pseudo @Any[], idx: mut Usize) -> void {
    # Implemented by the compiler
}

*func len(arr: pseudo @Any[]) -> Usize {
    # Implemented by the compiler
}

# External libraries

;; Use this struct to mark external libraries
struct Clib {
    # Implemented by the compiler
}

# Iter stuff

;; Use this struct to mark iterator functions
*struct IterCtor {
    # Implemented by the compiler
}

;; Represent a function as defined in the source code
;; The '$' operator returns a {Func}, '$*' returns array of {Func}s.
;;
;; The compiler creates one instance of this structure for each function
;; defined in the source code. It is intended to be used as argument to the
;; -of introspection functions (nameof, commentof, etcs).
;;
;; Manually creating instances of this struct is possible but will not generate
;; any actual functions (neither in the internal compiler-state nor in the
;; compiled code) and as such makes no sense.
*struct Func {
    # Empty
}

;; Create a callback from func {func}.
;; The callback type is guessed from the function
*func toCallback(fun : Func) = fun'callback;

;; Create a callback with type {cbType} from func {func}
*func toCallback(fun : Func, cbType: Any) -> %cbType {
    # implemented by the compiler
}

# Miscellaneous

# Bitwise Operations

*struct Bits8 {
    # Opaque to the programmer
}

*struct Bits16 {
    # Opaque to the programmer
}

*struct Bits32 {
    # Opaque to the programmer
}

*struct Bits64 {
    # Opaque to the programmer
}

;; Conversion integer type -> bits

*func to(a: (Ubyte, Byte), :Bits8) -> Bits8 {
    # implemented by the compiler
}

*func toBits(a: (Ubyte, Byte)) -> Bits8 {
    # implemented by the compiler
}

*func to(a: (Ushort, Short), :Bits16) -> Bits16 {
    # implemented by the compiler
}

*func toBits(a: (Ushort, Short)) -> Bits16 {
    # implemented by the compiler
}

*func to(a: (Uint, Int), :Bits32) -> Bits32 {
    # implemented by the compiler
}

*func toBits(a: (Uint, Int)) -> Bits32 {
    # implemented by the compiler
}

*func to(a: (Ulong, Long), :Bits64) -> Bits64 {
    # implemented by the compiler
}

*func toBits(a: (Ulong, Long)) -> Bits64 {
    # implemented by the compiler
}

*func to(a: Float, :Bits32) -> Bits32 {
    # implemented by the compiler
}

*func toBits(a: Float) -> Bits32 {
    # implemented by the compiler
}

*func to (a: Bits32, :Float) -> Float {
    # implemented by the compiler
}

*func to(a: Double, :Bits64) -> Bits64 {
    # implemented by the compiler
}

*func toBits(a: Double) -> Bits64 {
    # implemented by the compiler
}

*func to (a: Bits64, :Double) -> Double {
    # implemented by the compiler
}

;; Conversion bits -> integer type

*func to(a: Bits8, :Byte) -> Byte {
    # implemented by the compiler
}

*func to(a: Bits8, :Ubyte) -> Ubyte {
    # implemented by the compiler
}

*func to(a: Bits16, :Short) -> Short {
    # implemented by the compiler
}

*func to(a: Bits16, :Ushort) -> Ushort {
    # implemented by the compiler
}

*func to(a: Bits32, :Int) -> Int {
    # implemented by the compiler
}

*func to(a: Bits32, :Uint) -> Uint {
    # implemented by the compiler
}

*func to(a: Bits64, :Long) -> Long {
    # implemented by the compiler
}

*func to(a: Bits64, :Ulong) -> Ulong {
    # implemented by the compiler
}

;; Expanding or truncating bits

*func to(a: (Bits8, Bits16, Bits32, Bits64), :Bits8) -> Bits8 {
    # implemented by the compiler
}

*func to(a: (Bits8, Bits16, Bits32, Bits64), :Bits16) -> Bits16 {
    # implemented by the compiler
}

*func to(a: (Bits8, Bits16, Bits32, Bits64), :Bits32) -> Bits32 {
    # implemented by the compiler
}

*func to(a: (Bits8, Bits16, Bits32, Bits64), :Bits64) -> Bits64 {
    # implemented by the compiler
}


;; Bitwise and
*func and(a: (Bits8, Bits16, Bits32, Bits64), b: %a) -> %a {
    # implemented by the compiler
}

;; Bitwise or
*func or(a: (Bits8, Bits16, Bits32, Bits64), b: %a) -> %a {
    # implemented by the compiler
}

;; Bitwise xor
*func sub(a: (Bits8, Bits16, Bits32, Bits64), b: %a) -> %a {
    # implemented by the compiler
}

;; Bitwise not
*func not(a: (Bits8, Bits16, Bits32, Bits64)) -> %a {
    # implemented by the compiler
}

;; Compare for equality
*func cmp(a: (Bits8, Bits16, Bits32, Bits64), b: %a) -> Bool {
    # implemented by the compiler
}

;; Shift bits left a given number of {times}
;; *NOTE* If {times} is negative or larger than the number of bits in {a}
;; then a mask is applied to {times} before shifting. The mask is
;; * 0x03 - for Bits8  i.e. force a range of 0-7
;; * 0x0F - for Bits16 i.e. force a range of 0-15
;; * 0x1F - for Bits32 i.e. force a range of 0-31
;; * 0x3F - for Bits64 i.e. force a range of 0-61
*func shiftl(
    a: (Bits8, Bits16, Bits32, Bits64),
    times: (Byte, Ubyte, Short, Ushort, Int, Uint)
) -> %a {
    # implemented by the compiler
}

;; Shift bits right a given number of {times}
;; ...
*func shiftr(
    a: (Bits8, Bits16, Bits32, Bits64),
    times: (Byte, Ubyte, Short, Ushort, Int, Uint)
) -> %a {
    # implemented by the compiler
}

;; Arithmetic shift bits right a given number of {times}
;; ...
*func ashiftr(
    a: (Bits8, Bits16, Bits32, Bits64),
    times: (Byte, Ubyte, Short, Ushort, Int, Uint)
) -> %a {
    # implemented by the compiler
}

;; Global Stack Functionality

;; Used just to descriminate other types
*struct Global~[type:struct] {}

;; Get the global variable with type {a..type} from the global stack.
;; This function is guaranteed to return a reference to a valid object
;; even if not values has been explicitly set
*func get(a: pseudo Global) -> [ Ptr~[^a..type] ] {
    # implemented by the compiler
}

;; Push {a} onto the global stack.
;; The global stack despite being called global is per execution unit.
;; It is not global in the sense of other programming langauges like C.
;; {a} must be a variable and the newly created etry on the stack is
;; auto popped when {a} goes out of scope
*func set(a: pseudo Global, val: pseudo Any) -> void {
    # implemented by the compiler
}
